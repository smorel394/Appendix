import Mathlib.CategoryTheory.Abelian.Basic
import Mathlib.Algebra.Homology.HomotopyCategory
import Mathlib.CategoryTheory.Limits.FunctorCategory.Finite
import Mathlib.CategoryTheory.ComposableArrows

universe u v

open CategoryTheory Category Functor Limits

open scoped ZeroObject

variable {C : Type u} [Category.{v} C] [Preadditive C]

namespace CategoryTheory

namespace Adel

open ComposableArrows

abbrev zero : Fin 3 := ‚ü®0, by omega‚ü©
abbrev one : Fin 3 := ‚ü®1, by omega‚ü©
abbrev two : Fin 3 := ‚ü®2, by omega‚ü©

def homotopic : HomRel (ComposableArrows C 2) :=
  fun X Y u v ‚Ü¶ ‚àÉ (œÉ‚ÇÅ : X.obj one ‚ü∂ Y.obj zero) (œÉ‚ÇÇ : X.obj two ‚ü∂ Y.obj one),
                u.app one = (œÉ‚ÇÅ ‚â´ Y.map' 0 1) + (X.map' 1 2 ‚â´ œÉ‚ÇÇ) + v.app one

instance : Congruence (homotopic (C := C)) where
  equivalence := by
    refine {refl u := ?_, symm h := ?_, trans h h' := ?_}
    ¬∑ exact ‚ü®0, 0, by simp‚ü©
    ¬∑ obtain ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© := h
      use -œÉ‚ÇÅ, -œÉ‚ÇÇ
      rw [eq]
      dsimp
      simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.neg_comp, Preadditive.comp_neg]
      abel
    ¬∑ obtain ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© := h
      obtain ‚ü®œÉ‚ÇÅ', œÉ‚ÇÇ', eq'‚ü© := h'
      use œÉ‚ÇÅ + œÉ‚ÇÅ', œÉ‚ÇÇ + œÉ‚ÇÇ'
      rw [eq, eq']
      dsimp
      simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.add_comp, Preadditive.comp_add]
      abel
  compLeft u _ _ h := by
    obtain ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© := h
    use u.app one ‚â´ œÉ‚ÇÅ, u.app two ‚â´ œÉ‚ÇÇ
    rw [NatTrans.comp_app, eq]
    dsimp
    simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.comp_add, assoc, add_left_inj,
      add_right_inj]
    conv_lhs => rw [‚Üê assoc, ‚Üê NatTrans.naturality, assoc]
    rfl
  compRight v h := by
    obtain ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© := h
    use œÉ‚ÇÅ ‚â´ v.app zero, œÉ‚ÇÇ ‚â´ v.app one
    rw [NatTrans.comp_app, eq]
    dsimp
    simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.add_comp, assoc, NatTrans.naturality]

end Adel

open Adel

variable (C) in
def Adel := Quotient (homotopic (C := C))

namespace Adel

instance : Category (Adel C) := by
  dsimp [Adel]
  infer_instance

variable (C) in
def quotient : ComposableArrows C 2 ‚•§ Adel C := Quotient.functor (homotopic (C := C))

instance : (quotient C).Full := Quotient.full_functor _

instance : (quotient C).EssSurj := Quotient.essSurj_functor _

-- Is this useful? It's very evil.
lemma quotient_obj_surjective (X : Adel C) :
    ‚àÉ (K : ComposableArrows C 2), (quotient _).obj K = X :=
  ‚ü®_, rfl‚ü©

instance : Preadditive (Adel C) := Quotient.preadditive _ (by
  rintro _ _ _ _ _ _ ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© ‚ü®œÉ‚ÇÅ', œÉ‚ÇÇ', eq'‚ü©
  use œÉ‚ÇÅ + œÉ‚ÇÅ', œÉ‚ÇÇ + œÉ‚ÇÇ'
  rw [NatTrans.app_add, NatTrans.app_add, eq, eq']
  dsimp
  simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.add_comp, Preadditive.comp_add]
  abel)

instance : (quotient C).Additive where

section ZeroObject

instance [HasZeroObject C] : HasZeroObject (Adel C) where
  zero := by
    use (quotient C).obj 0
    rw [IsZero.iff_id_eq_zero, ‚Üê (quotient C).map_id, id_zero, (quotient C).map_zero]

end ZeroObject

section Biproducts

variable [HasFiniteBiproducts C]

instance : HasFiniteProducts (ComposableArrows C 2) := by
  dsimp [ComposableArrows]
  infer_instance

instance : HasFiniteBiproducts (ComposableArrows C 2) :=
  HasFiniteBiproducts.of_hasFiniteProducts

instance : HasFiniteProducts (Adel C) where
  out n := by
    refine {has_limit F := HasLimit.mk ?_}
    set g : Fin n ‚Üí ComposableArrows C 2 := fun j ‚Ü¶ (quotient C).objPreimage (F.obj {as := j})
    set Œπ : Discrete.functor g ‚ãô (quotient C) ‚âÖ F :=
      Discrete.natIso (fun _ ‚Ü¶ (quotient C).objObjPreimageIso _)
    refine {cone := ?_, isLimit := ?_}
    ¬∑ exact (Cones.postcompose Œπ.hom).obj ((quotient C).mapCone (limit.cone (Discrete.functor g)))
    ¬∑ exact (IsLimit.postcomposeHomEquiv _ _).invFun (isLimitOfPreserves (quotient C)
        (limit.isLimit _))

instance : HasFiniteBiproducts (Adel C) := HasFiniteBiproducts.of_hasFiniteProducts

instance : HasBinaryBiproducts (ComposableArrows C 2) := hasBinaryBiproducts_of_finite_biproducts _

instance : HasBinaryBiproducts (Adel C) := hasBinaryBiproducts_of_finite_biproducts _

end Biproducts

section Cokernels

variable [HasBinaryBiproducts C]

section Candidate

variable {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y')

noncomputable abbrev candcoker : ComposableArrows C 2 :=
  ComposableArrows.mk‚ÇÇ (biprod.map (Y'.map' 0 1) (X'.map' 1 2) +
  biprod.snd ‚â´ u'.app one ‚â´ biprod.inl) (biprod.map (Y'.map' 1 2) (ùüô (X'.obj two)))

noncomputable abbrev candœÄ : Y' ‚ü∂ candcoker u' := by
  refine ComposableArrows.homMk‚ÇÇ biprod.inl biprod.inl biprod.inl ?_ ?_
  ¬∑ dsimp
    simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.comp_add, biprod.inl_map]
    rw [biprod.inl_snd_assoc]
    simp only [Fin.isValue, homOfLE_leOfHom, zero_comp, add_zero]
    rfl
  ¬∑ dsimp
    change _ = biprod.inl ‚â´ biprod.map _ _
    simp

lemma candcondition : homotopic (u' ‚â´ candœÄ u') 0 := by
  use biprod.inr, -biprod.inr
  dsimp
  simp only [Fin.isValue, homOfLE_leOfHom, Preadditive.comp_add, biprod.inr_map,
    BinaryBicone.inr_snd_assoc, Preadditive.comp_neg, add_zero]
  rw [add_assoc]; erw [add_add_neg_cancel'_right]
  rfl

lemma candepi {T : ComposableArrows C 2} (v : candcoker u' ‚ü∂ T) (hv : homotopic (candœÄ u' ‚â´ v) 0) :
    homotopic v 0 := by
  obtain ‚ü®œÉ‚ÇÅ, œÉ‚ÇÇ, eq‚ü© := hv
  use biprod.desc œÉ‚ÇÅ 0, biprod.desc œÉ‚ÇÇ (biprod.inr ‚â´ v.app one)
  dsimp at eq
  simp only [Fin.isValue, homOfLE_leOfHom, add_zero] at eq
  rw [NatTrans.app_zero, add_zero]
  change _ = _ + (biprod.map (Y'.map' 1 2) (ùüô (X'.obj two))) ‚â´ _
  exact biprod.hom_ext' _ _ (by simp [eq]) (by simp)

instance : Epi ((quotient C).map (candœÄ u')) := by
  rw [Preadditive.epi_iff_cancel_zero]
  intro T v hv
  set e := (quotient C).objObjPreimageIso T
  set v' := (quotient C).preimage (v ‚â´ e.inv)
  have hv' : homotopic (candœÄ u' ‚â´ v') 0 := by
    refine (Quotient.functor_map_eq_iff _ _ _).mp ?_
    change (quotient C).map _ = (quotient C).map _
    dsimp [v']
    rw [map_comp, Functor.map_zero, map_preimage, ‚Üê assoc, hv, zero_comp]
  have : (quotient C).map v' = 0 := (Quotient.functor_map_eq_iff _ _ _).mpr (candepi u' v' hv'  )
  dsimp [v'] at this
  rw [(quotient C).map_preimage] at this
  simp only [Preadditive.IsIso.comp_right_eq_zero] at this
  exact this

noncomputable abbrev canddesc {T : ComposableArrows C 2} (v : Y' ‚ü∂ T) (hv : homotopic (u' ‚â´ v) 0) :
    candcoker u' ‚ü∂ T := by
  set œÉ‚ÇÅ := hv.choose
  set œÉ‚ÇÇ := hv.choose_spec.choose
  set eq : _ = œÉ‚ÇÅ ‚â´ _ + _ ‚â´ œÉ‚ÇÇ + _ := hv.choose_spec.choose_spec
  dsimp at eq
  simp only [Fin.isValue, homOfLE_leOfHom, add_zero] at eq
  refine ComposableArrows.homMk‚ÇÇ (biprod.desc (v.app zero) œÉ‚ÇÅ) (biprod.desc (v.app one) (- œÉ‚ÇÇ))
    (biprod.desc (v.app two) (- œÉ‚ÇÇ ‚â´ T.map' 1 2)) ?_ ?_
  ¬∑ exact biprod.hom_ext' _ _ (by dsimp; simp) (by dsimp; simp [eq])
  ¬∑ change biprod.map (Y'.map' 1 2) (ùüô (X'.obj two)) ‚â´ _ = _
    exact biprod.hom_ext' _ _ (by dsimp [two]; simp) (by dsimp; simp)

lemma candfac {T : ComposableArrows C 2} (v : Y' ‚ü∂ T) (hv : homotopic (u' ‚â´ v) 0) :
    candœÄ u' ‚â´ canddesc u' v hv = v := by
  refine ComposableArrows.hom_ext‚ÇÇ ?_ ?_ ?_
  ¬∑ dsimp [canddesc]; simp
  ¬∑ dsimp [canddesc]; simp
  ¬∑ dsimp
    change biprod.inl ‚â´ biprod.desc (v.app two) (- hv.choose_spec.choose ‚â´ T.map' 1 2) = _
    simp [two]

end Candidate

noncomputable def cocone_aux {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y') :
    Cocone (parallelPair u' 0 ‚ãô quotient C) := by
  refine (Cocones.precompose (diagramIsoParallelPair (parallelPair u' 0 ‚ãô quotient C)).hom).obj
    (Cofork.ofœÄ ((quotient C).map (candœÄ u')) ?_)
  suffices eq : (quotient C).map (u' ‚â´ (candœÄ u')) = (quotient C).map 0 by
    dsimp at eq ‚ä¢
    simp only [map_comp, map_preimage, Category.assoc, Functor.map_zero,
      Preadditive.IsIso.comp_left_eq_zero, zero_comp] at eq ‚ä¢
    exact eq
  exact (Quotient.functor_map_eq_iff _ _ _).mpr (candcondition u')

noncomputable abbrev œÄ' {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y')
    (c : Cocone (parallelPair u' 0 ‚ãô quotient C)) : Y' ‚ü∂ (quotient C).objPreimage c.pt :=
  (quotient C).preimage (c.Œπ.app WalkingParallelPair.one ‚â´
  ((quotient C).objObjPreimageIso c.pt).inv)

omit [HasBinaryBiproducts C] in
lemma condition' {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y')
    (c : Cocone (parallelPair u' 0 ‚ãô quotient C)) : homotopic (u' ‚â´ œÄ' u' c) 0 := by
  refine (Quotient.functor_map_eq_iff _ _ _).mp ?_
  change (quotient C).map _ = (quotient C).map _
  dsimp [œÄ']
  rw [map_comp,Functor.map_preimage, ‚Üê cancel_mono ((quotient C).objObjPreimageIso c.pt).hom]
  simp only [Nat.reduceAdd, assoc, Iso.inv_hom_id, comp_id, Functor.map_zero, zero_comp]
  have := c.w WalkingParallelPairHom.left
  dsimp at this
  rw [this]
  have := c.w WalkingParallelPairHom.right
  dsimp at this
  rw [‚Üê this]
  simp

noncomputable def cocone_isColimit {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y') :
    IsColimit (cocone_aux u') where
  desc c := (quotient C).map (canddesc u' (œÄ' u' c) (condition' u' c)) ‚â´
    ((quotient C).objObjPreimageIso c.pt).hom
  fac c j := by
    match j with
    | WalkingParallelPair.zero =>
      have eq := c.w WalkingParallelPairHom.right
      have eq' := (cocone_aux u').w WalkingParallelPairHom.right
      dsimp at eq eq'
      rw [‚Üê eq, ‚Üê eq']
      dsimp
      simp
    | WalkingParallelPair.one =>
      have := candfac u' (œÄ' u' c) (condition' u' c)
      dsimp [cocone_aux]
      simp only [Fin.isValue, homOfLE_leOfHom, id_comp]
      rw [‚Üê assoc, ‚Üê (quotient C).map_comp, this]
      dsimp [œÄ']
      rw [(quotient C).map_preimage]
      simp
  uniq c m hm := by
    rw [‚Üê cancel_epi ((quotient C).map (candœÄ u'))]
    have := hm WalkingParallelPair.one
    dsimp [cocone_aux] at this
    simp only [Fin.isValue, homOfLE_leOfHom, id_comp] at this
    rw [this, ‚Üê assoc, ‚Üê (quotient C).map_comp, candfac u' (œÄ' u' c) (condition' u' c)]
    dsimp [œÄ']
    rw [(quotient C).map_preimage]
    simp

instance {X' Y' : ComposableArrows C 2} (u' : X' ‚ü∂ Y') :
    HasColimit (parallelPair u' 0 ‚ãô quotient C) :=
  HasColimit.mk {cocone := cocone_aux u', isColimit := cocone_isColimit u'}

open WalkingParallelPair WalkingParallelPairHom in
noncomputable instance {X Y : Adel C} (u : X ‚ü∂ Y) : HasColimit (parallelPair u 0) := by
  set X' := (quotient C).objPreimage X
  set Y' := (quotient C).objPreimage Y
  set u' := (quotient C).preimage (((quotient C).objObjPreimageIso X).hom ‚â´ u ‚â´
    ((quotient C).objObjPreimageIso Y).inv)
  set g : WalkingParallelPair ‚•§ ComposableArrows C 2 := parallelPair u' 0
  set Œπ : g ‚ãô quotient C ‚âÖ parallelPair u 0 := by
    refine NatIso.ofComponents (fun j ‚Ü¶ ?_) (fun u ‚Ü¶ ?_)
    ¬∑ match j with
      | .zero => exact (quotient C).objObjPreimageIso X
      | .one => exact (quotient C).objObjPreimageIso Y
    ¬∑ match u with
      | .id _ => dsimp; simp
      | .left => dsimp [g]; rw [(quotient C).map_preimage]; simp
      | .right => dsimp [g]; simp
  rw [‚Üê hasColimit_iff_of_iso Œπ]
  infer_instance

end Cokernels

end Adel

end CategoryTheory
