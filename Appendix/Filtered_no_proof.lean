/-
Copyright (c) 2021 Luke Kershaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Luke Kershaw, Jo√´l Riou
-/
import Mathlib.CategoryTheory.Triangulated.Functor
import Mathlib.CategoryTheory.ObjectProperty.Shift
import Mathlib.CategoryTheory.ObjectProperty.FullSubcategory
import Mathlib.CategoryTheory.Adjunction.FullyFaithful
import Mathlib.CategoryTheory.Adjunction.Reflective
import Mathlib.CategoryTheory.Triangulated.Adjunction
import Mathlib.Tactic.Linarith
import Appendix.Mathlib.CategoryTheory.Triangulated.Subcategory
import Appendix.Lemmas

/-!
# Filtered Triangulated Categories

-/

noncomputable section

open CategoryTheory Preadditive Limits

universe v v‚ÇÄ v‚ÇÅ v‚ÇÇ u u‚ÇÄ u‚ÇÅ u‚ÇÇ

namespace CategoryTheory

open Category Pretriangulated ZeroObject

/-
We work in a preadditive category `C` equipped with an additive shift.
-/
variable {C : Type u} [Category.{v, u} C]

attribute [local instance] endofunctorMonoidalCategory

section

variable [HasShift C (‚Ñ§ √ó ‚Ñ§)]

instance Shift‚ÇÅ : HasShift C ‚Ñ§ where
  shift := (Discrete.addMonoidalFunctor (AddMonoidHom.inl ‚Ñ§ ‚Ñ§)).comp HasShift.shift
  shiftMonoidal := by
    have := HasShift.shiftMonoidal (C := C) (A := ‚Ñ§ √ó ‚Ñ§)
    infer_instance

variable (C) in
def FilteredShift := C

instance : Category (FilteredShift C) := by
  dsimp only [FilteredShift]
  infer_instance

noncomputable instance : HasShift (FilteredShift C) (‚Ñ§ √ó ‚Ñ§) := by
  dsimp only [FilteredShift]
  infer_instance

noncomputable instance : HasShift (FilteredShift C) ‚Ñ§ where
  shift := (Discrete.addMonoidalFunctor (AddMonoidHom.inr ‚Ñ§ ‚Ñ§)).comp HasShift.shift
  shiftMonoidal := by
    have := HasShift.shiftMonoidal (C := C) (A := ‚Ñ§ √ó ‚Ñ§)
    infer_instance

instance [HasZeroObject C] : HasZeroObject (FilteredShift C) := by
  dsimp only [FilteredShift]
  infer_instance

instance [Preadditive C] : Preadditive (FilteredShift C) := by
  dsimp only [FilteredShift]
  infer_instance

variable (C) in
def shiftFunctor‚ÇÇ (n : ‚Ñ§) : C ‚•§ C := shiftFunctor (FilteredShift C) n

instance (n : ‚Ñ§) : (shiftFunctor‚ÇÇ C n).IsEquivalence :=
  instIsEquivalenceShiftFunctor (FilteredShift C) n

instance [Preadditive C] (n : ‚Ñ§) [(shiftFunctor C (Prod.mk (0 : ‚Ñ§) n)).Additive] :
    (shiftFunctor (FilteredShift C) n).Additive := by
  change (shiftFunctor C (Prod.mk 0 n)).Additive
  infer_instance

instance [Preadditive C] (n : ‚Ñ§) [(shiftFunctor C (Prod.mk (0 : ‚Ñ§) n)).Additive] :
    (shiftFunctor‚ÇÇ C n).Additive := by
  change (shiftFunctor C (Prod.mk 0 n)).Additive
  infer_instance

instance AdditiveShift‚ÇÅ [Preadditive C] (n : ‚Ñ§) [(shiftFunctor C (Prod.mk n (0 : ‚Ñ§))).Additive] :
    (shiftFunctor C n).Additive := by
  change Functor.Additive (shiftFunctor C (n, (0 : ‚Ñ§)))
  exact inferInstance

lemma shift‚ÇÅFunctorZero_eq_shiftFunctorZero :
    shiftFunctorZero C ‚Ñ§ = shiftFunctorZero C (‚Ñ§ √ó ‚Ñ§) := by
  rw [shiftFunctorZero, shiftFunctorZero, Iso.symm_eq_iff]
  apply Iso.ext
  rw [Functor.Monoidal.ŒµIso_hom, Functor.Monoidal.ŒµIso_hom]
  erw [Functor.LaxMonoidal.comp_Œµ]
  simp; rfl

lemma shift‚ÇÅFunctorAdd_eq_shiftFunctorAdd (a b : ‚Ñ§) :
    shiftFunctorAdd C a b = shiftFunctorAdd C (a, (0 : ‚Ñ§)) (b, (0 : ‚Ñ§)) := by
  dsimp [shiftFunctorAdd]
  rw [Iso.symm_eq_iff]
  ext1
  dsimp [Functor.Monoidal.ŒºIso_hom]
  erw [Functor.LaxMonoidal.comp_Œº]
  simp only [Discrete.addMonoidalFunctor_obj, AddMonoidHom.inl_apply,
    Functor.CoreMonoidal.toMonoidal_toLaxMonoidal, eqToIso_refl, Discrete.functor_map_id, comp_id]
  rfl

instance Shift‚ÇÇCommShift‚ÇÅ (n : ‚Ñ§) : (shiftFunctor‚ÇÇ C n).CommShift ‚Ñ§ where
iso m := (shiftFunctorAdd' C (m, (0 : ‚Ñ§)) ((0 : ‚Ñ§), n) (m, n) (by simp only [Prod.mk_add_mk,
    add_zero, zero_add])).symm.trans (shiftFunctorAdd' C ((0 : ‚Ñ§), n) (m, (0 : ‚Ñ§)) (m, n)
    (by simp only [Prod.mk_add_mk, add_zero, zero_add]))
zero := sorry
add := sorry

end

set_option quotPrecheck false in
/-- shifting an object `X` by `(0, n)` is obtained by the notation `X‚ü™n‚ü´` -/
notation -- Any better notational suggestions?
X "‚ü™" n "‚ü´" => (shiftFunctor‚ÇÇ C n).obj X

set_option quotPrecheck false in
/-- shifting a morphism `f` by `(0, n)` is obtained by the notation `f‚ü™n‚ü´'` -/
notation f "‚ü™" n "‚ü´'" => (shiftFunctor‚ÇÇ C n).map f

open ObjectProperty

variable (C)
variable [HasShift C (‚Ñ§ √ó ‚Ñ§)] [Preadditive C] [HasZeroObject C]

/-- Definition A.1.1(1):
Definition of a filtered pretriangulated category.
-/
class FilteredTriangulated [‚àÄ p : ‚Ñ§ √ó ‚Ñ§, Functor.Additive (shiftFunctor C p)]
  [hC : Pretriangulated C]
where
  /-- the second shift acts by triangulated functors -/
  shift‚ÇÇ_triangle : ‚àÄ (n : ‚Ñ§), (shiftFunctor‚ÇÇ C n).IsTriangulated
  /-- morphism into the object with shifted filtration -/
  Œ± : ùü≠ C ‚ü∂ shiftFunctor‚ÇÇ C 1
  /-- objets with filtration concentrated in degree `‚â§ n` -/
  LE : ‚Ñ§ ‚Üí Triangulated.Subcategory C
  /-- objets with filtration concentrated in degree `‚â• n` -/
  GE : ‚Ñ§ ‚Üí Triangulated.Subcategory C
  LE_closedUnderIsomorphisms : ‚àÄ (n : ‚Ñ§), IsClosedUnderIsomorphisms (LE n).P :=
    by infer_instance
  GE_closedUnderIsomorphisms : ‚àÄ (n : ‚Ñ§), IsClosedUnderIsomorphisms (GE n).P :=
    by infer_instance
  LE_zero_le : (LE 0).P ‚â§ (LE 1).P
  GE_one_le : (GE 1).P ‚â§ (GE 0).P
  LE_shift : ‚àÄ (n a n' : ‚Ñ§), a + n = n' ‚Üí ‚àÄ (X : C), (LE n).P X ‚Üí (LE n').P (X‚ü™a‚ü´)
  GE_shift : ‚àÄ (n a n' : ‚Ñ§), a + n = n' ‚Üí ‚àÄ (X : C), (GE n).P X ‚Üí (GE n').P (X‚ü™a‚ü´)
  zero' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), (GE 1).P X ‚Üí (LE 0).P Y ‚Üí f = 0
  adj_left : ‚àÄ ‚¶ÉX Y : C‚¶Ñ, (GE 1).P X ‚Üí (LE 0).P Y ‚Üí Function.Bijective
    (fun (f : Y‚ü™1‚ü´ ‚ü∂ X) ‚Ü¶ (Œ±.app Y ‚â´ f : Y ‚ü∂ X))
  adj_right : ‚àÄ ‚¶ÉX Y : C‚¶Ñ, (GE 1).P X ‚Üí (LE 0).P Y ‚Üí Function.Bijective
    (fun (f : Y ‚ü∂ X) ‚Ü¶ (f ‚â´ Œ±.app X : Y ‚ü∂ (X‚ü™1‚ü´)))
  LE_exhaustive : ‚àÄ (X : C), ‚àÉ (n : ‚Ñ§), (LE n).P X
  GE_exhaustive : ‚àÄ (X : C), ‚àÉ (n : ‚Ñ§), (GE n).P X
  Œ±_s : ‚àÄ (X : C), (Œ±.app X)‚ü™1‚ü´' = Œ±.app (X‚ü™1‚ü´)
  exists_triangle_one_zero : ‚àÄ (X : C), ‚àÉ (A : C) (B : C) (_ : (GE 1).P A) (_ : (LE 0).P B)
    (f : A ‚ü∂ X) (g : X ‚ü∂ B) (h : B ‚ü∂ A‚ü¶1‚üß),
    Triangle.mk f g h ‚àà distinguishedTriangles


namespace FilteredTriangulated

attribute [instance] LE_closedUnderIsomorphisms GE_closedUnderIsomorphisms

open ObjectProperty

variable {C}

variable [‚àÄ p : ‚Ñ§ √ó ‚Ñ§, Functor.Additive (CategoryTheory.shiftFunctor C p)]
  [hC : Pretriangulated C] [hP : FilteredTriangulated C]

instance (n : ‚Ñ§) : (shiftFunctor‚ÇÇ C n).IsTriangulated := hP.shift‚ÇÇ_triangle n

lemma LE_monotone : Monotone (fun n ‚Ü¶ (hP.LE n).P) := by
  let H := fun (a : ‚Ñï) => ‚àÄ (n : ‚Ñ§), (LE n).P ‚â§ (hP.LE (n + a)).P
  suffices ‚àÄ (a : ‚Ñï), H a by
    intro n‚ÇÄ n‚ÇÅ h
    obtain ‚ü®a, ha‚ü© := Int.nonneg_def.1 h
    obtain rfl : n‚ÇÅ = n‚ÇÄ + a := by omega
    apply this
  have H_zero : H 0 := fun n => by
    simp only [Nat.cast_zero, add_zero]
    rfl
  have H_one : H 1 := fun n X hX =>
    (LE_closedUnderIsomorphisms (n + 1)).of_iso ((shiftEquiv' (FilteredShift C)
    (-n) n (by rw [neg_add_cancel])).unitIso.symm.app X) (LE_shift 1 n (n + 1) rfl _
    (LE_zero_le _ (LE_shift n (-n) 0 (by rw [neg_add_cancel]) X hX)))
  have H_add : ‚àÄ (a b c : ‚Ñï) (_ : a + b = c) (_ : H a) (_ : H b), H c := by
    intro a b c h ha hb n
    rw [‚Üê h, Nat.cast_add, ‚Üê add_assoc]
    exact (ha n).trans (hb (n+a))
  intro a
  induction' a with a ha
  ¬∑ exact H_zero
  ¬∑ exact H_add a 1 _ rfl ha H_one

lemma GE_antitone : Antitone (fun n ‚Ü¶ (hP.GE n).P) := by
  let H := fun (a : ‚Ñï) => ‚àÄ (n : ‚Ñ§), (GE (n + a)).P ‚â§ (hP.GE n).P
  suffices ‚àÄ (a : ‚Ñï), H a by
    intro n‚ÇÄ n‚ÇÅ h
    obtain ‚ü®a, ha‚ü© := Int.nonneg_def.1 h
    obtain rfl : n‚ÇÅ = n‚ÇÄ + a := by omega
    apply this
  have H_zero : H 0 := fun n => by
    simp only [Nat.cast_zero, add_zero]
    rfl
  have H_one : H 1 := fun n X hX =>
    (GE_closedUnderIsomorphisms n).of_iso ((shiftEquiv' (FilteredShift C)
    (-n) n (by rw [neg_add_cancel])).unitIso.symm.app X) (GE_shift 0 n n (by rw [add_zero]) _
    (GE_one_le _ (GE_shift (n + 1) (-n) 1 (by rw [neg_add_cancel_left]) X hX)))
  have H_add : ‚àÄ (a b c : ‚Ñï) (_ : a + b = c) (_ : H a) (_ : H b), H c := by
    intro a b c h ha hb n
    rw [‚Üê h, Nat.cast_add, ‚Üê add_assoc ]
    exact (hb (n + a)).trans (ha n)
  intro a
  induction' a with a ha
  ¬∑ exact H_zero
  ¬∑ exact H_add a 1 _ rfl ha H_one

/-- Given a filtration `F` on a pretriangulated category `C`, the property `IsLE X n`
holds if `X : C` is `‚â§ n` for the filtration. -/
class IsLE (X : C) (n : ‚Ñ§) : Prop where
  le : (hP.LE n).P X

/-- Given a filtration `F` on a pretriangulated category `C`, the property `IsGE X n`
holds if `X : C` is `‚â• n` for the filtration. -/
class IsGE (X : C) (n : ‚Ñ§) : Prop where
  ge : (hP.GE n).P X

lemma mem_of_isLE (X : C) (n : ‚Ñ§) [IsLE X n] : (LE n).P X := IsLE.le
lemma mem_of_isGE (X : C) (n : ‚Ñ§) [IsGE X n] : (GE n).P X := IsGE.ge

-- Should the following be instances or lemmas? Let's make them instances and see what happens.
instance zero_isLE (n : ‚Ñ§) : IsLE (0 : C) n := {le := (LE n).zero}

instance zero_isGE (n : ‚Ñ§) : IsGE (0 : C) n := {ge := (GE n).zero}

instance shift_isLE_of_isLE (X : C) (n a : ‚Ñ§) [IsLE X n] : IsLE (X‚ü¶a‚üß) n :=
  {le := (LE n).shift X a (mem_of_isLE X n)}

instance shift_isGE_of_isGE (X : C) (n a : ‚Ñ§) [IsGE X n] : IsGE (X‚ü¶a‚üß) n :=
  {ge := (GE n).shift X a (mem_of_isGE X n)}

instance LE_ext‚ÇÅ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsLE T.obj‚ÇÇ n]
    [IsLE T.obj‚ÇÉ n] : IsLE T.obj‚ÇÅ n :=
  {le := (LE n).ext‚ÇÅ T hT (mem_of_isLE T.obj‚ÇÇ n) (mem_of_isLE T.obj‚ÇÉ n)}

instance LE_ext‚ÇÇ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsLE T.obj‚ÇÅ n]
    [IsLE T.obj‚ÇÉ n] : IsLE T.obj‚ÇÇ n :=
  {le := (LE n).ext‚ÇÇ T hT (mem_of_isLE T.obj‚ÇÅ n) (mem_of_isLE T.obj‚ÇÉ n)}

instance LE_ext‚ÇÉ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsLE T.obj‚ÇÅ n]
    [IsLE T.obj‚ÇÇ n] : IsLE T.obj‚ÇÉ n :=
  {le := (LE n).ext‚ÇÉ T hT (mem_of_isLE T.obj‚ÇÅ n) (mem_of_isLE T.obj‚ÇÇ n)}

instance GE_ext‚ÇÅ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsGE T.obj‚ÇÇ n]
    [IsGE T.obj‚ÇÉ n] : IsGE T.obj‚ÇÅ n :=
  {ge := (GE n).ext‚ÇÅ T hT (mem_of_isGE T.obj‚ÇÇ n) (mem_of_isGE T.obj‚ÇÉ n)}

instance GE_ext‚ÇÇ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsGE T.obj‚ÇÅ n]
    [IsGE T.obj‚ÇÉ n] : IsGE T.obj‚ÇÇ n :=
  {ge := (GE n).ext‚ÇÇ T hT (mem_of_isGE T.obj‚ÇÅ n) (mem_of_isGE T.obj‚ÇÉ n)}

instance GE_ext‚ÇÉ (T : Triangle C) (hT : T ‚àà distinguishedTriangles) (n : ‚Ñ§) [IsGE T.obj‚ÇÅ n]
    [IsGE T.obj‚ÇÇ n] : IsGE T.obj‚ÇÉ n :=
  {ge := (GE n).ext‚ÇÉ T hT (mem_of_isGE T.obj‚ÇÅ n) (mem_of_isGE T.obj‚ÇÇ n)}

lemma isLE_of_iso {X Y : C} (e : X ‚âÖ Y) (n : ‚Ñ§) [IsLE X n] : IsLE Y n where
  le := prop_of_iso (LE n).P e (mem_of_isLE X n)

lemma isGE_of_iso {X Y : C} (e : X ‚âÖ Y) (n : ‚Ñ§) [IsGE X n] : IsGE Y n where
  ge := prop_of_iso (GE n).P e (mem_of_isGE X n)

lemma isLE_of_LE (X : C) (p q : ‚Ñ§) (hpq : p ‚â§ q) [IsLE X p] : IsLE X q where
  le := LE_monotone hpq _ (mem_of_isLE X p)

lemma isGE_of_GE (X : C) (p q : ‚Ñ§) (hpq : p ‚â§ q) [IsGE X q] : IsGE X p where
  ge := GE_antitone hpq _ (mem_of_isGE X q)

lemma isLE_shift (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') [IsLE X n] :
    IsLE (X‚ü™a‚ü´) n' :=
  ‚ü®LE_shift n a n' hn' X (mem_of_isLE X n)‚ü©

lemma isGE_shift (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') [IsGE X n] :
    IsGE (X‚ü™a‚ü´) n' :=
  ‚ü®GE_shift n a n' hn' X (mem_of_isGE X n)‚ü©

lemma isLE_of_shift (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') [IsLE (X‚ü™a‚ü´) n'] :
    IsLE X n := by
  have h := isLE_shift (X‚ü™a‚ü´) n' (-a) n (by linarith)
  exact isLE_of_iso (show ((X‚ü™a‚ü´)‚ü™-a‚ü´) ‚âÖ X from
  (shiftEquiv (FilteredShift C) a).unitIso.symm.app X) n

lemma isGE_of_shift (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') [IsGE (X‚ü™a‚ü´) n'] :
    IsGE X n := by
  have h := isGE_shift (X‚ü™a‚ü´) n' (-a) n (by linarith)
  exact isGE_of_iso (show ((X‚ü™a‚ü´)‚ü™-a‚ü´) ‚âÖ X from
  (shiftEquiv (FilteredShift C) a).unitIso.symm.app X) n

lemma isLE_shift_iff (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') :
    IsLE (X‚ü™a‚ü´) n' ‚Üî IsLE X n := by
  constructor
  ¬∑ intro
    exact isLE_of_shift X n a n' hn'
  ¬∑ intro
    exact isLE_shift X n a n' hn'

lemma isGE_shift_iff (X : C) (n a n' : ‚Ñ§) (hn' : a + n = n') :
    IsGE (X‚ü™a‚ü´) n' ‚Üî IsGE X n := by
  constructor
  ¬∑ intro
    exact isGE_of_shift X n a n' hn'
  ¬∑ intro
    exact isGE_shift X n a n' hn'

lemma zero {X Y : C} (f : X ‚ü∂ Y) (n‚ÇÄ n‚ÇÅ : ‚Ñ§) (h : n‚ÇÄ < n‚ÇÅ)
    [IsGE X n‚ÇÅ] [IsLE Y n‚ÇÄ] : f = 0 := by
  have := isLE_shift Y n‚ÇÄ (-n‚ÇÄ) 0 (by simp only [neg_add_cancel])
  have := isGE_shift X n‚ÇÅ (-n‚ÇÄ) (n‚ÇÅ-n‚ÇÄ) (by linarith)
  have := isGE_of_GE (X‚ü™-n‚ÇÄ‚ü´) 1 (n‚ÇÅ-n‚ÇÄ) (by linarith)
  apply (shiftFunctor‚ÇÇ C (-n‚ÇÄ)).map_injective
  simp only [Functor.map_zero]
  apply zero'
  ¬∑ apply mem_of_isGE
  ¬∑ apply mem_of_isLE

lemma zero_of_isGE_of_isLE {X Y : C} (f : X ‚ü∂ Y) (n‚ÇÄ n‚ÇÅ : ‚Ñ§) (h : n‚ÇÄ < n‚ÇÅ)
    (_ : IsGE X n‚ÇÅ) (_ : IsLE Y n‚ÇÄ) : f = 0 :=
  zero f n‚ÇÄ n‚ÇÅ h

lemma isZero (X : C) (n‚ÇÄ n‚ÇÅ : ‚Ñ§) (h : n‚ÇÄ < n‚ÇÅ)
    [IsGE X n‚ÇÅ] [IsLE X n‚ÇÄ] : IsZero X := by
  rw [IsZero.iff_id_eq_zero]
  exact zero _ n‚ÇÄ n‚ÇÅ h

section Triangle

/-! Generalization of `exists_triangle_one_zero`.
-/
lemma exists_triangle (X : C) (n m : ‚Ñ§) (h : m + 1 = n) : ‚àÉ (A : C) (B : C) (_ : IsGE A n)
    (_ : IsLE B m) (f : A ‚ü∂ X) (g : X ‚ü∂ B) (h : B ‚ü∂ A‚ü¶1‚üß),
    Triangle.mk f g h ‚àà distinguishedTriangles := by
  obtain ‚ü®A', B', hA', hB', f', g', h', dT'‚ü© := hP.exists_triangle_one_zero (X‚ü™-m‚ü´)
  have : IsLE B' 0 := {le := hB'}
  have : IsGE A' 1 := {ge := hA'}
  use A'‚ü™m‚ü´, B'‚ü™m‚ü´, isGE_shift A' 1 m n h, isLE_shift B' 0 m m (add_zero _),
    f'‚ü™m‚ü´' ‚â´ (shiftNegShift (C := FilteredShift C) X m).hom,
    (shiftNegShift (C := FilteredShift C) X m).inv ‚â´ g'‚ü™m‚ü´',
    h'‚ü™m‚ü´' ‚â´ ((shiftFunctor‚ÇÇ C m).commShiftIso (1 : ‚Ñ§)).hom.app A'
  refine (Pretriangulated.distinguished_iff_of_iso (Pretriangulated.Triangle.isoMk _ _
    ?_ ?_ ?_ ?_ ?_ ?_)).mp ((hP.shift‚ÇÇ_triangle m).map_distinguished _ dT')
  ¬∑ exact Iso.refl _
  ¬∑ exact shiftNegShift (C := FilteredShift C) X m
  ¬∑ exact Iso.refl _
  ¬∑ dsimp; simp only [id_comp]
  ¬∑ dsimp; simp only [comp_id, Iso.hom_inv_id_app_assoc]
  ¬∑ dsimp; simp only [Functor.map_id, comp_id, id_comp]

end Triangle

end FilteredTriangulated

open FilteredTriangulated

attribute [instance] LE_closedUnderIsomorphisms GE_closedUnderIsomorphisms

variable {C}

variable [‚àÄ p : ‚Ñ§ √ó ‚Ñ§, Functor.Additive (CategoryTheory.shiftFunctor C p)]
  [hC : Pretriangulated C] [hCP : FilteredTriangulated C]

variable {D : Type u‚ÇÄ} [Category.{v‚ÇÄ} D]
variable [HasShift D (‚Ñ§ √ó ‚Ñ§)] [Preadditive D] [HasZeroObject D]
  [‚àÄ p : ‚Ñ§ √ó ‚Ñ§, Functor.Additive (shiftFunctor D p)]
  [hD : Pretriangulated D] [hDP : FilteredTriangulated D]

variable {A : Type u‚ÇÅ} [Category.{v‚ÇÅ} A] [HasShift A ‚Ñ§] [Preadditive A] [HasZeroObject A]
  [‚àÄ p : ‚Ñ§, Functor.Additive (shiftFunctor A p)] [Pretriangulated A]

variable {B : Type u‚ÇÇ} [Category.{v‚ÇÇ} B] [HasShift B ‚Ñ§] [Preadditive B] [HasZeroObject B]
  [‚àÄ p : ‚Ñ§, Functor.Additive (shiftFunctor B p)] [Pretriangulated B]


namespace Functor

variable (F : C ‚•§ D)

/-- Definition A.1.1(2).
A filtered triangulated functor is a functor `F : C ‚•§ D` that commutes with
both shifts (i.e. with the shifts from `‚Ñ§ √ó ‚Ñ§`), is triangulated and sends the objects of `LE 0`
(resp. `GE 0`) to objects of `LE 0` (resp. `GE 0`) and that is compatible with the
morphisms `Œ±`.
-/
class IsFilteredTriangulated [F.CommShift (‚Ñ§ √ó ‚Ñ§)] where
  preserves_LE : ‚àÄ (X : C), IsLE X 0 ‚Üí IsLE (F.obj X) 0
  preserves_GE : ‚àÄ (X : C), IsGE X 0 ‚Üí IsGE (F.obj X) 0
  commutes_Œ± : ‚àÄ (X : C),
    hDP.Œ±.app (F.obj X) ‚â´ (F.commShiftIso ((0,1) : ‚Ñ§ √ó ‚Ñ§)).inv.app X = F.map (hCP.Œ±.app X)

instance [F.CommShift (‚Ñ§ √ó ‚Ñ§)] : F.CommShift ‚Ñ§ := sorry

instance [F.CommShift (‚Ñ§ √ó ‚Ñ§)] [F.IsFilteredTriangulated] : F.IsTriangulated := sorry

instance preserves_LE_of_isFilteredTriangulated [F.CommShift (‚Ñ§ √ó ‚Ñ§)] [F.IsFilteredTriangulated]
    (X : C) (n : ‚Ñ§) [IsLE X n] : IsLE (F.obj X) n := sorry

instance preserves_GE_of_isFilteredTriangulated [F.CommShift (‚Ñ§ √ó ‚Ñ§)] [F.IsFilteredTriangulated]
    (X : C) (n : ‚Ñ§) [IsGE X n] : IsGE (F.obj X) n := sorry

end Functor

section Over

variable (C A) in
/--
Definition A.1.1(3), first part:
Filtered triangulated category over a triangulated category.
-/
structure isFilteredTriangulated_over where
  functor : A ‚•§ C
  commShift : functor.CommShift ‚Ñ§
  triangulated : functor.IsTriangulated
  ff : functor.FullyFaithful
  essImage (X : C) : functor.essImage X ‚Üî IsLE X 0 ‚àß IsGE X 0

instance (L : isFilteredTriangulated_over C A) : L.functor.Faithful := L.ff.faithful

instance (L : isFilteredTriangulated_over C A) : L.functor.Full := L.ff.full

lemma isFilteredTriangulated_over_image (L : isFilteredTriangulated_over C A) (X : A) :
    IsLE (L.functor.obj X) 0 ‚àß IsGE (L.functor.obj X) 0 := by
  rw [‚Üê L.essImage]
  exact Functor.obj_mem_essImage _ _

-- This gives an equivalence of categories from `A` to the full subcategory of
-- objects of `C` that are `LE 0` and `GE 0`.
def isFilteredTriangulated_over_equiv (L : isFilteredTriangulated_over C A) :
    A ‚•§ ObjectProperty.FullSubcategory (fun (X : C) ‚Ü¶ IsLE X 0 ‚àß IsGE X 0) :=
  ObjectProperty.lift _ L.functor (isFilteredTriangulated_over_image L)

instance (L : isFilteredTriangulated_over C A) :
    Functor.IsEquivalence (isFilteredTriangulated_over_equiv L) where
      faithful := by
        have := L.ff.faithful
        exact instFaithfulFullSubcategoryLift _ _ (isFilteredTriangulated_over_image L)
      full := by
        have := L.ff.full
        exact instFullFullSubcategoryLift _ _ (isFilteredTriangulated_over_image L)
      essSurj :=
        {mem_essImage X := by
           obtain ‚ü®Y, h‚ü© := (L.essImage X.1).mpr X.2
           exact ‚ü®Y, Nonempty.intro (InducedCategory.isoMk (Classical.choice h))‚ü©
        }

def isFilteredTriangulated_over_equiv_inv_comp (L : isFilteredTriangulated_over C A) :
    (isFilteredTriangulated_over_equiv L).inv ‚ãô L.functor ‚âÖ ObjectProperty.Œπ _ :=
  Iso.inverseCompIso (ObjectProperty.liftCompŒπIso _ _ _).symm
  (G := (isFilteredTriangulated_over_equiv L).asEquivalence)

/--
Definition A.1.1(3), second part:
Lifting of a triangulated functor.
-/
structure Functor.filteredLifting (L‚ÇÅ : isFilteredTriangulated_over C A)
    (L‚ÇÇ : isFilteredTriangulated_over D B) (F : A ‚•§ B)
    [F.CommShift ‚Ñ§] [F.IsTriangulated] where
  functor : C ‚•§ D
  commShift : functor.CommShift (‚Ñ§ √ó ‚Ñ§)
  triang : functor.IsFilteredTriangulated
  compat : F ‚ãô L‚ÇÇ.functor ‚âÖ L‚ÇÅ.functor ‚ãô functor
-- I am guessing that the compatibility isomorphism should satisfy some compatibilities,
-- notably with the "commutation with shifts" isomorphisms.

variable (L‚ÇÅ : isFilteredTriangulated_over C A)
    (L‚ÇÇ : isFilteredTriangulated_over D B) (F : A ‚•§ B)
    [F.CommShift ‚Ñ§] [F.IsTriangulated] (FT : F.filteredLifting L‚ÇÅ L‚ÇÇ)

instance : FT.functor.CommShift (‚Ñ§ √ó ‚Ñ§) := FT.commShift

instance : FT.functor.IsFilteredTriangulated := FT.triang

end Over

namespace FilteredTriangulated
section Truncation

-- Prop A.1.3 (i)
-- First sentence.

instance LE_reflective_aux (n : ‚Ñ§) (X : C) : Limits.HasInitial (StructuredArrow X
    (FilteredTriangulated.LE (C := C) n).Œπ) := by
  obtain ‚ü®A, B, hA, hB, f, g, h, dT‚ü© := exists_triangle X (n + 1) n rfl
  set B' : (FilteredTriangulated.LE (C := C) n).category := ‚ü®B, hB.le‚ü©
  set Y : StructuredArrow X (FilteredTriangulated.LE (C := C) n).Œπ := StructuredArrow.mk (Y := B') g
  have : ‚àÄ Z, Nonempty (Y ‚ü∂ Z) := by
    intro Z
    refine Nonempty.intro ?_
    set hyp := Pretriangulated.Triangle.yoneda_exact‚ÇÇ _ dT Z.hom (zero_of_isGE_of_isLE (f ‚â´ Z.hom)
      n (n + 1) (by simp only [lt_add_iff_pos_right, zero_lt_one]) hA {le := Z.right.2})
    exact StructuredArrow.homMk (Classical.choose hyp) (Classical.choose_spec hyp).symm
  have : ‚àÄ Z, Subsingleton (Y ‚ü∂ Z) := by
    intro Z
    have eq : ‚àÄ (u : Y ‚ü∂ Z), g ‚â´ u.right = Z.hom := by
      intro u
      have := u.w
      dsimp at this
      simp only [id_comp] at this
      exact this.symm
    refine Subsingleton.intro (fun u v ‚Ü¶ StructuredArrow.hom_ext _ _ ?_)
    rw [‚Üê sub_eq_zero]
    obtain ‚ü®w, eq‚ü© := Pretriangulated.Triangle.yoneda_exact‚ÇÉ _ dT (u.right - v.right)
      (by dsimp; rw [comp_sub, eq u, eq v, sub_self])
    rw [eq, zero_of_isGE_of_isLE w n (n + 1) (by simp only [lt_add_iff_pos_right, zero_lt_one])
      (shift_isGE_of_isGE A (n + 1) 1) {le := Z.right.2}, comp_zero]
  exact Limits.hasInitial_of_unique Y

instance LE_reflective (n : ‚Ñ§) : Reflective ((FilteredTriangulated.LE (C := C) n).Œπ :
    (FilteredTriangulated.LE n).category ‚•§ C) where
      L := leftAdjointOfStructuredArrowInitials (FilteredTriangulated.LE (C := C) n).Œπ
      adj := adjunctionOfStructuredArrowInitials _

instance GE_coreflective (n : ‚Ñ§) : Coreflective (FilteredTriangulated.GE (C := C) n).Œπ := sorry
-- Use `CategoryTheory.isLeftAdjoint_of_costructuredArrowTerminals`.

def truncLE (n : ‚Ñ§) : C ‚•§ C := (reflector ((FilteredTriangulated.LE (C := C) n).Œπ) : C ‚•§
    (FilteredTriangulated.LE n).category) ‚ãô
    ((FilteredTriangulated.LE (C := C) n).Œπ)
-- The "left adjoint" of the inclusion.

def truncGE (n : ‚Ñ§) : C ‚•§ C := coreflector (FilteredTriangulated.GE (C := C) n).Œπ ‚ãô
  (FilteredTriangulated.GE (C := C) n).Œπ
-- The "right adjoint" of the inclusion.

instance (X : C) (n : ‚Ñ§) : IsLE ((truncLE n).obj X) n :=
  {le := Triangulated.Subcategory.Œπ_obj_mem _ _}

instance (X : C) (n : ‚Ñ§) : IsGE ((truncGE n).obj X) n :=
  {ge := Triangulated.Subcategory.Œπ_obj_mem _ _}

def essImage_of_LE (X : C) (n : ‚Ñ§) [IsLE X n] :
    (FilteredTriangulated.LE (C := C) n).Œπ.essImage X := by
  have : (hCP.LE n).P X := IsLE.le
  use ‚ü®X, this‚ü©
  exact Nonempty.intro (Iso.refl _)

def essImage_of_GE (X : C) (n : ‚Ñ§) [IsGE X n] :
    (FilteredTriangulated.GE (C := C) n).Œπ.essImage X := by
  have : (hCP.GE n).P X := IsGE.ge
  use ‚ü®X, this‚ü©
  exact Nonempty.intro (Iso.refl _)

def truncLEœÄ (n : ‚Ñ§) : ùü≠ _ ‚ü∂ truncLE (C := C) n :=
  (reflectorAdjunction (FilteredTriangulated.LE (C := C) n).Œπ).unit
-- Unit of the adjunction.

instance truncLEœÄ_iso_of_LE (X : C) (n : ‚Ñ§) [IsLE X n] : IsIso ((truncLEœÄ n).app X) :=
  Functor.essImage.unit_isIso (essImage_of_LE X n)

noncomputable def descTruncLE {X Y : C} (f : X ‚ü∂ Y) (n : ‚Ñ§) [IsLE Y n] :
    (truncLE n).obj X ‚ü∂ Y := (truncLE n).map f ‚â´ inv ((truncLEœÄ n).app Y)

@[reassoc (attr := simp)]
lemma œÄ_descTruncLE {X Y : C} (f : X ‚ü∂ Y) (n : ‚Ñ§) [IsLE Y n] :
    (truncLEœÄ n).app X ‚â´ descTruncLE f n = f := by
  dsimp [descTruncLE]
  rw [‚Üê assoc, ‚Üê (truncLEœÄ n).naturality, assoc, IsIso.hom_inv_id, Functor.id_map, comp_id]

def truncGEŒπ (n : ‚Ñ§) : truncGE (C := C) n ‚ü∂ ùü≠ _ :=
  (coreflectorAdjunction (FilteredTriangulated.GE (C := C) n).Œπ).counit
-- Counit of the adjunction.

instance truncGEŒπ_iso_of_GE (X : C) (n : ‚Ñ§) [IsGE X n] : IsIso ((truncGEŒπ n).app X) :=
  Functor.essImage.counit_isIso (essImage_of_GE X n)

def liftTruncGE {X Y : C} (f : X ‚ü∂ Y) (n : ‚Ñ§) [IsGE X n] :
    X ‚ü∂ (truncGE n).obj Y := inv ((truncGEŒπ n).app X) ‚â´ (truncGE n).map f

@[reassoc (attr := simp)]
lemma liftTruncGE_Œπ {X Y : C} (f : X ‚ü∂ Y) (n : ‚Ñ§) [IsGE X n] :
    liftTruncGE f n ‚â´ (truncGEŒπ n).app Y = f := by
  dsimp [liftTruncGE]
  rw [assoc, (truncGEŒπ n).naturality, Functor.id_map, ‚Üê assoc, IsIso.inv_hom_id, id_comp]

/-
Bonus: Morphism from a `(truncLE n).obj X` to an object `‚â§ n` are equal if they are so after
composing on the left with `truncLEœÄ`, and morphism from an object `‚â• n` to a
`(truncGE n).obj X` are equal if they are so after composing on the right with `truncGEŒπ`.
-/

lemma from_truncLE_obj_ext (n : ‚Ñ§) {Y : C} {X : C}
    (f‚ÇÅ f‚ÇÇ : (truncLE n).obj X ‚ü∂ Y) (h : (truncLEœÄ n).app X ‚â´ f‚ÇÅ =
    (truncLEœÄ n).app X ‚â´ f‚ÇÇ) [IsLE Y n] :
    f‚ÇÅ = f‚ÇÇ := by
  rw [‚Üê cancel_mono ((truncLEœÄ n).app Y)]
  apply ((reflectorAdjunction (LE (C := C) n).Œπ).homEquiv _ _).injective
  dsimp
  simp only [Adjunction.homEquiv_apply, Functor.comp_obj]
  change (truncLEœÄ n).app X ‚â´ f‚ÇÅ ‚â´ _ = _
  rw [‚Üê assoc, h, assoc]
  rfl

lemma to_truncGE_obj_ext (n : ‚Ñ§) {X : C} {Y : C}
    (f‚ÇÅ f‚ÇÇ : X ‚ü∂ (truncGE n).obj Y) (h : f‚ÇÅ ‚â´ (truncGEŒπ n).app Y =
    f‚ÇÇ ‚â´ (truncGEŒπ n).app Y) [IsGE X n] :
    f‚ÇÅ = f‚ÇÇ := by
  rw [‚Üê cancel_epi ((truncGEŒπ n).app X)]
  apply ((coreflectorAdjunction (GE (C := C) n).Œπ).homEquiv _ _).symm.injective
  dsimp
  simp only [Adjunction.homEquiv_symm_apply]
  change (_ ‚â´ f‚ÇÅ) ‚â´ (truncGEŒπ n).app Y = _
  rw [assoc, h, ‚Üê assoc]
  rfl

-- Second sentence.
-- The truncation functors are triangulated.

instance (n : ‚Ñ§) : (reflector (FilteredTriangulated.LE (C := C) n).Œπ).CommShift ‚Ñ§ :=
  (reflectorAdjunction _).leftAdjointCommShift ‚Ñ§

instance (n : ‚Ñ§) : (reflectorAdjunction (FilteredTriangulated.LE (C := C) n).Œπ).CommShift ‚Ñ§ :=
  (reflectorAdjunction _).commShift_of_rightAdjoint ‚Ñ§

instance (n : ‚Ñ§) : (truncLE (C := C) n).CommShift ‚Ñ§ := by
  dsimp [truncLE]
  infer_instance

instance (n : ‚Ñ§  ) : (reflector (FilteredTriangulated.LE (C := C) n).Œπ).IsTriangulated :=
  (reflectorAdjunction _).isTriangulated_leftAdjoint

instance (n : ‚Ñ§) : (truncLE (C := C) n).IsTriangulated := by
  dsimp [truncLE]
  infer_instance

instance (n : ‚Ñ§) : (coreflector (FilteredTriangulated.GE (C := C) n).Œπ).CommShift ‚Ñ§ :=
  (coreflectorAdjunction _).rightAdjointCommShift ‚Ñ§

instance (n : ‚Ñ§) : (coreflectorAdjunction (FilteredTriangulated.GE (C := C) n).Œπ).CommShift ‚Ñ§ :=
  (coreflectorAdjunction _).commShift_of_leftAdjoint ‚Ñ§

instance (n : ‚Ñ§) : (truncGE (C := C) n).CommShift ‚Ñ§ := by
  dsimp [truncGE]
  infer_instance

instance (n : ‚Ñ§  ) : (coreflector (FilteredTriangulated.GE (C := C) n).Œπ).IsTriangulated :=
  (coreflectorAdjunction _).isTriangulated_rightAdjoint

instance (n : ‚Ñ§) : (truncGE (C := C) n).IsTriangulated := by
  dsimp [truncGE]
  infer_instance

-- The truncation functors preserve the subcategories `hCP.LE m` and `hCP.GE m` for
-- every `m : ‚Ñ§`.

instance (n m : ‚Ñ§) (X : C) [IsLE X m] : IsLE ((truncLE n).obj X) m := sorry

instance (n m : ‚Ñ§) (X : C) [IsGE X m] : IsGE ((truncLE n).obj X) m := sorry

instance (n m : ‚Ñ§) (X : C) [IsLE X m] : IsLE ((truncGE n).obj X) m := sorry

instance (n m : ‚Ñ§) (X : C) [IsGE X m] : IsGE ((truncGE n).obj X) m := sorry

-- We need to switch the order, because the proof of A.1.3 (ii) uses A.1.3 (iii).
-- Prop A.1.3 (iii) but with general indices

-- Existence. Version with and without the `n + 1`.
-- This is cheating in a way, because the connecting morphism in the triangle is not arbitrary,
-- it's given by the axioms. (The statements are still okay thanks to the uniqueness.)

def truncLEŒ¥GE' (n m : ‚Ñ§) (h : n + 1 = m) :
    truncLE n ‚ü∂ truncGE m ‚ãô shiftFunctor C (1 : ‚Ñ§) := sorry

@[simps!]
noncomputable def triangleGELE' (n m : ‚Ñ§) (h : n + 1 = m) : C ‚•§ Triangle C :=
  Triangle.functorMk (truncGEŒπ m) (truncLEœÄ n) (truncLEŒ¥GE' n m h)

lemma triangleGELE'_distinguished (n m : ‚Ñ§) (h : n + 1 = m) (X : C) :
    (triangleGELE' n m h).obj X ‚àà distTriang C := sorry

def truncLEŒ¥GE (n : ‚Ñ§) :
    truncLE n ‚ü∂ truncGE (n + 1) ‚ãô shiftFunctor C (1 : ‚Ñ§) := truncLEŒ¥GE' n (n + 1) rfl

@[simps!]
def triangleGELE (n : ‚Ñ§) : C ‚•§ Triangle C := triangleGELE' n (n + 1) rfl

lemma triangleGELE_distinguished (n : ‚Ñ§) (X : C) :
    (triangleGELE n).obj X ‚àà distTriang C :=
  triangleGELE'_distinguished n (n + 1) rfl X

-- Uniqueness.
-- In the paper, this says that any distinguished triangle `A ‚ü∂ X ‚ü∂ B ‚ü∂ A[1]` with `A ‚â§ n` and
-- `B ‚â• n + 1` is isomorphic to `triangleGELE n X` in a unique way. Actually, this is not
-- quite correct, because we only have uniqueness if we require the morphism of triangles
-- to be `ùüô X` on the second objects. Also, the other morphisms are already explicit and
-- uniquely determined, they are given by `descTruncLE` and `liftTruncGE`, so the real content
-- is that these morphisms are isomorphisms.

lemma isIso_descTruncLE_of_fiber_ge (n : ‚Ñ§) {T : Triangle C} (dT : T ‚àà distTriang C)
    [IsGE T.obj‚ÇÅ (n + 1)] [IsLE T.obj‚ÇÉ n] : IsIso (descTruncLE T.mor‚ÇÇ n) := sorry

lemma isIso_liftTruncGE_of_cone_le (n : ‚Ñ§) {T : Triangle C} (dT : T ‚àà distTriang C)
    [IsGE T.obj‚ÇÅ n] [IsLE T.obj‚ÇÉ (n - 1)] : IsIso (liftTruncGE T.mor‚ÇÅ n) := sorry

section Commute
/-
Before proving A.1.3 (ii), we establish a criterion for triangulated endofunctors of `C`
to commute with the truncation functors (up to an isomorphism which will arise naturally).
It is better to make this more general, as it will be used again.
-/

variable (F : C ‚•§ D)

/-! If `F` preserves the subcategories of objects `‚â§ n`, then we get a morphism
`F ‚ãô truncLE n ‚ü∂ truncLE n ‚ãô F`.
-/
def commute_truncLE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsLE X n ‚Üí IsLE (F.obj X) n) :
    F ‚ãô truncLE n ‚ü∂ truncLE n ‚ãô F :=
      have : ‚àÄ X, IsLE (F.obj ((truncLE n).obj X)) n := fun _ ‚Ü¶ hF _ inferInstance
      {
        app X := descTruncLE (F.map ((truncLEœÄ n).app X)) n
        naturality X Y f := by
          dsimp
          refine from_truncLE_obj_ext n _ _ ?_
          dsimp [descTruncLE]
          rw [‚Üê cancel_mono ((truncLEœÄ n).app (F.obj ((truncLE n).obj Y)))]
          simp only [Functor.id_obj, assoc, IsIso.inv_hom_id, comp_id, NatIso.naturality_2'_assoc,
            Functor.id_map]
          slice_rhs 1 2 => rw [‚Üê F.map_comp, ‚Üê (truncLEœÄ n).naturality, Functor.id_map, F.map_comp]
          slice_lhs 1 2 => rw [‚Üê (truncLEœÄ n).naturality, Functor.id_map]
          slice_lhs 2 3 => rw [‚Üê (truncLEœÄ n).naturality, Functor.id_map]
          rw [assoc]
      }

lemma commute_truncLE_app (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsLE X n ‚Üí IsLE (F.obj X) n) (X : C) :
    have : IsLE (F.obj ((truncLE n).obj X)) n := hF _ inferInstance
    (commute_truncLE F n hF).app X = descTruncLE (F.map ((truncLEœÄ n).app X)) n := rfl

/-
Old definition using `Mates` (it complicated the proof of `commute_truncLE_app`):

abbrev Functor.onLE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsLE X n ‚Üí IsLE (F.obj X) n) :
    (FilteredTriangulated.LE (C := C) n).category ‚•§
    (FilteredTriangulated.LE (C := D) n).category :=
  ObjectProperty.lift _ (ObjectProperty.Œπ _ ‚ãô F) (fun X ‚Ü¶ (hF X.1 {le := X.2}).le)

def commute_truncLE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsLE X n ‚Üí IsLE (F.obj X) n) :
    F ‚ãô truncLE n ‚ü∂ truncLE n ‚ãô F :=
    set u : TwoSquare (FilteredTriangulated.LE (C := C) n).Œπ (F.onLE n hF) F
      (FilteredTriangulated.LE n).Œπ := by
    refine {app X := ?_, naturality X Y f := ?_}
    ¬∑ dsimp; exact ùüô _
    ¬∑ dsimp; simp; rfl
  exact (Functor.associator _ _ _).inv ‚â´ whiskerRight ((mateEquiv (reflectorAdjunction _)
    (reflectorAdjunction (FilteredTriangulated.LE n).Œπ)).symm u) _ ‚â´
    (Functor.associator _ _ _).hom ‚â´ whiskerLeft (reflector (FilteredTriangulated.LE n).Œπ) (ùüô _)  ‚â´
    (Functor.associator _ _ _).inv-/

/-! If `F` preserves the subcategories of objects `‚â§ n`, then we get a morphism
`F ‚ãô truncLE n ‚ü∂ truncLE n ‚ãô F`.
-/
def commute_truncGE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsGE X n ‚Üí IsGE (F.obj X) n) :
    truncGE n ‚ãô F ‚ü∂ F ‚ãô truncGE n :=
      have : ‚àÄ X, IsGE (F.obj ((truncGE n).obj X)) n := fun _ ‚Ü¶ hF _ inferInstance
      {
        app X := liftTruncGE (F.map ((truncGEŒπ n).app X)) n
        naturality X Y f := by
          dsimp
          refine to_truncGE_obj_ext n _ _ ?_
          dsimp [liftTruncGE]
          rw [‚Üê cancel_epi ((truncGEŒπ n).app (F.obj ((truncGE n).obj X)))]
          simp only [Functor.id_obj, assoc, NatTrans.naturality, Functor.id_map,
            IsIso.inv_hom_id_assoc, NatTrans.naturality_assoc]
          slice_lhs 2 3 => rw [‚Üê Functor.map_comp, (truncGEŒπ n).naturality, Functor.id_map,
            Functor.map_comp]
      }

lemma commute_truncGE_app (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsGE X n ‚Üí IsGE (F.obj X) n) (X : C) :
    have : IsGE (F.obj ((truncGE n).obj X)) n := hF _ inferInstance
    (commute_truncGE F n hF).app X = liftTruncGE (F.map ((truncGEŒπ n).app X)) n := rfl

/-
Old definition using `Mates` (it complicated the proof of `commute_truncGE_app`):

abbrev Functor.onGE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsGE X n ‚Üí IsGE (F.obj X) n) :
    (FilteredTriangulated.GE (C := C) n).category ‚•§
    (FilteredTriangulated.GE (C := D) n).category :=
  ObjectProperty.lift _ (ObjectProperty.Œπ _ ‚ãô F) (fun X ‚Ü¶ (hF X.1 {ge := X.2}).ge)

def commute_truncGE (n : ‚Ñ§) (hF : ‚àÄ (X : C), IsGE X n ‚Üí IsGE (F.obj X) n) :
    truncGE n ‚ãô F ‚ü∂ F ‚ãô truncGE n := by
  set u : TwoSquare (F.onGE n hF) (FilteredTriangulated.GE (C := C) n).Œπ
      (FilteredTriangulated.GE (C := D) n).Œπ F := by
    refine {app X := ?_, naturality X Y f := ?_}
    ¬∑ dsimp; exact ùüô _
    ¬∑ dsimp; simp; rfl
  refine ?_ ‚â´ whiskerRight (mateEquiv (coreflectorAdjunction _) (coreflectorAdjunction _) u) _
    ‚â´ (Functor.associator _ _ _).hom
  exact (Functor.associator _ _ _).hom ‚â´ whiskerLeft _ (ùüô _) ‚â´ (Functor.associator _ _ _).inv
-/

/-!
If `F` is triangulated and preserves the categories of objects `‚â§ n` and `‚â• n + 1`, then
`commute_truncLE` is an isomorphism.
-/
lemma isIso_commute_truncLE [F.CommShift ‚Ñ§] [F.IsTriangulated] (n : ‚Ñ§)
    (hFL : ‚àÄ (X : C), IsLE X n ‚Üí IsLE (F.obj X) n)
    (hFG : ‚àÄ (X : C), IsGE X (n + 1) ‚Üí IsGE (F.obj X) (n + 1)) :
    IsIso (commute_truncLE F n hFL) := by
  have : ‚àÄ (X : C), IsIso ((commute_truncLE F n hFL).app X) := by
    intro X
    rw [commute_truncLE_app]
    have : IsLE (F.mapTriangle.obj ((triangleGELE n).obj X)).obj‚ÇÉ n :=
      hFL ((truncLE n).obj X) inferInstance
    have : IsGE (F.mapTriangle.obj ((triangleGELE n).obj X)).obj‚ÇÅ (n + 1) :=
      hFG ((truncGE (n + 1)).obj X) inferInstance
    exact isIso_descTruncLE_of_fiber_ge n (F.map_distinguished _ (triangleGELE_distinguished n X))
  exact NatIso.isIso_of_isIso_app _

/-!
If `F` is triangulated and preserves the categories of objects `‚â• n` and `‚â§ n - 1`, then
`commute_truncGE` is an isomorphism.
-/
lemma isIso_commute_truncGE [F.CommShift ‚Ñ§] [F.IsTriangulated] (n : ‚Ñ§)
    (hFL : ‚àÄ (X : C), IsLE X (n - 1) ‚Üí IsLE (F.obj X) (n - 1))
    (hFG : ‚àÄ (X : C), IsGE X n ‚Üí IsGE (F.obj X) n) :
    IsIso (commute_truncGE F n hFG) := by
  have : ‚àÄ (X : C), IsIso ((commute_truncGE F n hFG).app X) := by
    intro X
    rw [commute_truncGE_app]
    have : IsGE (F.mapTriangle.obj ((triangleGELE' (n - 1) n
        (sub_add_cancel _ _)).obj X)).obj‚ÇÅ n := hFG ((truncGE n).obj X) inferInstance
    have : IsLE (F.mapTriangle.obj ((triangleGELE' (n - 1) n
        (sub_add_cancel _ _)).obj X)).obj‚ÇÉ (n - 1) := hFL ((truncLE (n - 1)).obj X) inferInstance
    exact isIso_liftTruncGE_of_cone_le n (F.map_distinguished _ (triangleGELE'_distinguished
      (n - 1) n (sub_add_cancel _ _) X))
  exact NatIso.isIso_of_isIso_app _

end Commute

-- Prop A.1.3 (ii)

def truncLEGE (a b : ‚Ñ§) : C ‚•§ C := truncGE a ‚ãô truncLE b

def truncGELE (a b : ‚Ñ§) : C ‚•§ C := truncLE b ‚ãô truncGE a

/-abbrev truncLE_onGE (n m : ‚Ñ§) :
    (FilteredTriangulated.GE (C := C) m).P.FullSubcategory ‚•§
    (FilteredTriangulated.GE (C := C) m).P.FullSubcategory := by
  refine ObjectProperty.lift _ ?_ (fun X ‚Ü¶ ?_)
  ¬∑ exact ObjectProperty.Œπ _ ‚ãô truncLE n
  ¬∑ have : IsGE X.1 m := {ge := X.2}
    exact (instIsGEObjTruncLE n m X.1).ge-/

abbrev truncLEGEToGELE (a b : ‚Ñ§) : truncLEGE (C := C) a b ‚ü∂ truncGELE a b :=
  commute_truncLE (truncGE a) b (fun _ _ ‚Ü¶ inferInstance)

instance truncLEGEIsoGELE (a b : ‚Ñ§) : IsIso (truncLEGEToGELE a b (C := C)) :=
  isIso_commute_truncLE (truncGE a) b (fun _ _ ‚Ü¶ inferInstance) (fun _ _ ‚Ü¶ inferInstance)

lemma truncLEGEToGELE_comm (a b : ‚Ñ§) :
    truncGEŒπ (C := C) b ‚â´ truncLEœÄ a =
    whiskerLeft (truncGE b) (truncLEœÄ a) ‚â´ truncLEGEToGELE b a ‚â´
    whiskerLeft (truncLE a) (truncGEŒπ b) := by
  ext X
  dsimp [truncLEGEToGELE, commute_truncLE]
  simp only [œÄ_descTruncLE_assoc, NatTrans.naturality, Functor.id_obj, Functor.id_map]

lemma truncLEGEToGELE_uniq {a b : ‚Ñ§} {X : C}
    {f : (truncLEGE b a).obj X ‚ü∂ (truncGELE b a).obj X}
    (comm : (truncGEŒπ b).app X ‚â´ (truncLEœÄ a).app X =
    (truncLEœÄ a).app ((truncGE b).obj X) ‚â´ f ‚â´ (truncGEŒπ b).app ((truncLE a).obj X)) :
    f = (truncLEGEToGELE b a).app X := by
  have : IsLE ((truncGELE b a).obj X) a := by
    dsimp [truncGELE]; infer_instance
  refine from_truncLE_obj_ext a _ _ ?_
  have : IsGE ((ùü≠ C).obj ((truncGE b).obj X)) b := by
    rw [Functor.id_obj]; infer_instance
  refine to_truncGE_obj_ext b _ _ ?_
  rw [assoc, ‚Üê comm, ‚Üê NatTrans.comp_app, truncLEGEToGELE_comm]
  simp

-- More general version of A.1.3 (iii), same remarks as before on cheating.

def truncGELE_le_up (a b c : ‚Ñ§) (h : b ‚â§ c) :
    truncGELE (C := C) a c ‚ü∂ truncGELE a b := by
  dsimp [truncGELE]
  sorry

def truncGELE_le_down (a b c : ‚Ñ§) (h : a ‚â§ b) :
    truncGELE (C := C) b c ‚ü∂ truncGELE a c := sorry

def truncGELE_Œ¥ (a b c : ‚Ñ§) :
    truncGELE (C := C) a b ‚ü∂ truncGELE (b + 1) c ‚ãô shiftFunctor C (1 : ‚Ñ§) := sorry

def truncGELE_triangle (a b c : ‚Ñ§) (h : a ‚â§ b) (h' : b ‚â§ c) : C ‚•§ Triangle C :=
  Triangle.functorMk (truncGELE_le_down a (b + 1) c (by linarith)) (truncGELE_le_up a b c h')
  (truncGELE_Œ¥ a b c)

lemma truncGELE_triangle_distinguished (a b c : ‚Ñ§) (h : a ‚â§ b) (h' : b ‚â§ c) (X : C) :
    (truncGELE_triangle a b c h h').obj X ‚àà distTriang C := sorry

end Truncation
end FilteredTriangulated

-- Prop A.1.3 (iv): we need to explain what compatibilities are hidden under the
-- adjective "canonical".
-- Here, there is an isomorphism given by the universal property of the
-- adjoint.

-- Also, we actually want the isomorphisms for "second" shifts
-- by any integer, compatible with the zero and the addition, like in `Functor.CommShift`.
-- Let's introduce a new structure for this. (It should be a class really.)

def familyCommShift.isoZero (F : ‚Ñ§ ‚Üí (C ‚•§ C)) (n n' : ‚Ñ§) (h : n' = n) :
    shiftFunctor‚ÇÇ C 0 ‚ãô F n ‚âÖ F n' ‚ãô shiftFunctor‚ÇÇ C 0 :=
  Functor.CommShift.isoZero (F n) ‚Ñ§ ‚â™‚â´ eqToIso (X := F n ‚ãô shiftFunctor‚ÇÇ C 0)
  (Y := F n' ‚ãô shiftFunctor‚ÇÇ C 0) (by rw [h])

def familyCommShift.isoAdd (F : ‚Ñ§ ‚Üí (C ‚•§ C)) (n a b n' n'' : ‚Ñ§)
    (e‚ÇÅ : shiftFunctor‚ÇÇ C a ‚ãô F n ‚âÖ F n' ‚ãô shiftFunctor‚ÇÇ C a)
    (e‚ÇÇ : shiftFunctor‚ÇÇ C b ‚ãô F n' ‚âÖ F n'' ‚ãô shiftFunctor‚ÇÇ C b) :
    shiftFunctor‚ÇÇ C (a + b) ‚ãô F n ‚âÖ F n'' ‚ãô shiftFunctor‚ÇÇ C (a + b) :=
  isoWhiskerRight (shiftFunctorAdd' (FilteredShift C) b a (a + b) (add_comm _ _)) (F n)
  ‚â™‚â´ Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft (shiftFunctor‚ÇÇ C b) e‚ÇÅ ‚â™‚â´
  (Functor.associator _ _ _).symm ‚â™‚â´ isoWhiskerRight e‚ÇÇ (shiftFunctor‚ÇÇ C a) ‚â™‚â´
  Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft (F n'')
  (shiftFunctorAdd' (FilteredShift C) b a (a + b) (add_comm _ _)).symm

structure familyCommShift (F : ‚Ñ§ ‚Üí (C ‚•§ C)) where
  iso (n m n' : ‚Ñ§) (h : n' + m = n) : shiftFunctor‚ÇÇ C m ‚ãô F n ‚âÖ F n' ‚ãô shiftFunctor‚ÇÇ C m
  zero (n n' : ‚Ñ§) (h : n' = n) :
      iso n 0 n' (by simp [h]) = familyCommShift.isoZero F n n' h
  add (n a b n' n'' : ‚Ñ§) (h : n' + a = n) (h' : n'' + b = n') :
      iso n (a + b) n'' (by rw [add_comm a b, ‚Üê add_assoc, h', h]) =
      familyCommShift.isoAdd F n a b n' n'' (iso n a n' h) (iso n' b n'' h')

variable (C) in
abbrev shiftFunctor‚ÇÇ' (n m n' : ‚Ñ§) (h : n' + m = n) :
    (FilteredTriangulated.LE (C := C) n').P.FullSubcategory ‚•§
    (FilteredTriangulated.LE (C := C) n).P.FullSubcategory where
      obj X := ‚ü®(shiftFunctor‚ÇÇ C m).obj X.1,
        ((isLE_shift_iff X.1 n' m n (by rw [add_comm, h])).mpr {le := X.2}).le‚ü©
      map := (shiftFunctor‚ÇÇ C m).map
      map_id X := (shiftFunctor‚ÇÇ C m).map_id X.1
      map_comp := (shiftFunctor‚ÇÇ C m).map_comp

namespace FilteredTriangulated
-- Maybe this construction and the next should use `conjugateEquiv` instead?
def truncLE_commShift_hom (n m n' : ‚Ñ§) (h : n' + m = n) :
    shiftFunctor‚ÇÇ C m ‚ãô truncLE n ‚ü∂ truncLE n' ‚ãô shiftFunctor‚ÇÇ C m := by
  set u : TwoSquare (FilteredTriangulated.LE (C := C) n').Œπ (shiftFunctor‚ÇÇ' C n m n' h)
      (shiftFunctor‚ÇÇ C m) (FilteredTriangulated.LE n).Œπ :=
    {app X := ùüô _, naturality X Y f := by dsimp; rw [id_comp, comp_id]; rfl}
  refine (Functor.associator _ _ _).inv ‚â´ whiskerRight ((mateEquiv (reflectorAdjunction _)
    (reflectorAdjunction ((FilteredTriangulated.LE n).Œπ))).symm u) _ ‚â´
    (Functor.associator _ _ _).hom ‚â´ whiskerLeft _ (ùüô _)

instance (n m n' : ‚Ñ§) (h : n' + m = n) : IsIso (truncLE_commShift_hom (C := C) n m n' h) := sorry

def truncLE_commShift : familyCommShift (fun n ‚Ü¶ truncLE (C := C) n) where
  iso n m n' h := asIso (truncLE_commShift_hom (C := C) n m n' h)
  zero := sorry
  add := sorry

variable (C) in
abbrev shiftFunctor‚ÇÇ'' (n m n' : ‚Ñ§) (h : n' + m = n) :
    (FilteredTriangulated.GE (C := C) n').P.FullSubcategory ‚•§
    (FilteredTriangulated.GE (C := C) n).P.FullSubcategory where
      obj X := ‚ü®(shiftFunctor‚ÇÇ C m).obj X.1,
        ((isGE_shift_iff X.1 n' m n (by rw [add_comm, h])).mpr {ge := X.2}).ge‚ü©
      map := (shiftFunctor‚ÇÇ C m).map
      map_id X := (shiftFunctor‚ÇÇ C m).map_id X.1
      map_comp := (shiftFunctor‚ÇÇ C m).map_comp

def truncGE_commShift_inv (n m n' : ‚Ñ§) (h : n' + m = n) :
    truncGE n' ‚ãô shiftFunctor‚ÇÇ C m ‚ü∂ shiftFunctor‚ÇÇ C m ‚ãô truncGE n := by
  set u : TwoSquare (shiftFunctor‚ÇÇ'' C n m n' h) (FilteredTriangulated.GE (C := C) n').Œπ
      (FilteredTriangulated.GE (C := C) n).Œπ (shiftFunctor‚ÇÇ C m) :=
    {app X := ùüô _, naturality X Y f := by dsimp; rw [id_comp, comp_id]; rfl}
  refine ?_ ‚â´ whiskerRight ((mateEquiv (coreflectorAdjunction (GE n').Œπ)
    (coreflectorAdjunction (GE n).Œπ) u)) _ ‚â´ (Functor.associator _ _ _).hom
  exact ùüô _

instance (n m n' : ‚Ñ§) (h : n' + m = n) : IsIso (truncGE_commShift_inv (C := C) n m n' h) := sorry

def truncGE_commShift : familyCommShift (fun n ‚Ü¶ truncGE (C := C) n) where
  iso n m n' h := (asIso (truncGE_commShift_inv n m n' h)).symm
  zero := sorry
  add := sorry

end FilteredTriangulated

/-
The next thing in the paper is the definition, when we have a filtered triangulated category `C`
over a triangulated category `A`, of the "graded pieces" functors `Gr n : C ‚•§ A`, which use
an arbitrary quasi-inverse of the fully faithful functor `i : A ‚•§ C` on the essential image of
`i`.

Rather than using an arbitrary quasi-inverse, it makes things much simpler to use the one
given by the "forget the filtration" functor `ForgetFiltration : C ‚•§ A`, which has the
additional pleasant property that it is defined on all of `C` and so avoids an
`ObjectProperty.lift`. In fact, this is even better, as `ForgetFiltration` commutes with the
second shift, so we can directy defined `Gr n` as `truncGELE n n ‚ãô ForgetFiltration`.

For this, we need to change the order of statements and do Proposition A.1.6 first (this is
possible as that proposition makes no use of the functors `Gr n`).
-/

-- First a technical definition. (Is this really useful?)
variable {E E' M : Type*} [Category E] [Category E'] [AddMonoid M] [HasShift E M]

structure leftCommShift (G : M ‚Üí (E ‚•§ E')) where
  iso (a b c : M) (h : a = c + b) : shiftFunctor E b ‚ãô G a ‚âÖ G c
  zero (a c : M) (h : a = c) : iso a 0 c (by rw [add_zero, h]) =
      isoWhiskerRight (shiftFunctorZero E M) (G a) ‚â™‚â´ Functor.leftUnitor _ ‚â™‚â´
      eqToIso (by rw [h])
  add (a b b' c c' : M) (h : a = c + b) (h' : c = c' + b') :
      iso a (b' + b) c' (by rw [‚Üê add_assoc, ‚Üê h', h]) =
      isoWhiskerRight (shiftFunctorAdd E b' b) _ ‚â™‚â´ Functor.associator _ _ _ ‚â™‚â´
      isoWhiskerLeft _ (iso a b c h) ‚â™‚â´ iso c b' c' h'

namespace FilteredTriangulated
section Forget

variable (L : isFilteredTriangulated_over C A)

-- Proposition A.1.6 asserts the existence of a "forget the filtration" functor
-- `C ‚•§ A` with a slew of properties that uniquely characterize it.

-- Let's start with the existence statements.

def ForgetFiltration (L : isFilteredTriangulated_over C A) : C ‚•§ A := sorry

-- Property (a). Note that this is an existence statement (it asserts the existence
-- of an adjunction).

def ForgetFiltration_leftAdjoint :
    Adjunction (ObjectProperty.Œπ (fun (X : C) ‚Ü¶ IsLE X 0) ‚ãô ForgetFiltration L)
    (ObjectProperty.lift _ L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).1)) := sorry

-- Property (b). Same remark as for (a).

def ForgetFiltration_rightAdjoint :
    Adjunction (ObjectProperty.lift _ L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).2))
    (ObjectProperty.Œπ (fun (X : C) ‚Ü¶ IsGE X 0) ‚ãô ForgetFiltration L) := sorry

/-
Property (a) gives an isomorphism `L.functor ‚â´ ForgetFiltration ‚âÖ ùü≠ A` (by taking the counit
of the adjunction), and property (b) gives an isomorphism in the other direction
(by taking the unit of the adjunction). Although this is not stated in the paper, we want these
isomorphisms to be inverses of each other.
-/

lemma ForgetFiltration_iso_comp :
    (ForgetFiltration_rightAdjoint L).unit ‚â´ (ForgetFiltration_leftAdjoint L).counit = ùüô _ := sorry

-- Property (c).

lemma ForgetFiltration_shift (X : C) : IsIso ((ForgetFiltration L).map (hCP.Œ±.app X)) := sorry

-- This implies a full `leftCommShift` structure on `ForgetFiltration`.
-- I don't want to define this, since the existence of the `leftCommShift` structure (given by `Œ±`)
-- should probably replace property (c).

def ForgetFiltration_commShift :
    leftCommShift (fun (n : ‚Ñ§) ‚Ü¶ ForgetFiltration (C := C) L) (E := FilteredShift C) := sorry

-- Property (d).

lemma ForgetFiltration_ff (X Y : C) (hX : IsLE X 0) (hY : IsGE Y 0) :
    Function.Bijective (fun (f : X ‚ü∂ Y) ‚Ü¶ (ForgetFiltration L).map f) := sorry

-- The functor should also be triangulated.
-- (This actually follows from the other conditions, but is
-- not stated in the paper. Note that the first instance contains
-- data! So I am actually cheating here, because the data is determined
-- by the other properties of `ForgetFiltration`.)

instance : (ForgetFiltration L).CommShift ‚Ñ§ := sorry

instance : (ForgetFiltration L).IsTriangulated := sorry

-- The uniqueness statements are painful to state because we don't just want an
-- isomorphism, we want it to respect the extra structure (i.e. the adjunction).

def ForgetFiltration_uniq_left (G : C ‚•§ A)
    (left_adj : Adjunction (ObjectProperty.Œπ (fun (X : C) ‚Ü¶ IsLE X 0) ‚ãô G)
    (ObjectProperty.lift _ L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).1)))
    (shift : ‚àÄ (X : C), IsIso (G.map (hCP.Œ±.app X))) :
    ForgetFiltration L ‚âÖ G := sorry

lemma ForgetFiltration_uniq_left_compat (G : C ‚•§ A)
    (left_adj : Adjunction (ObjectProperty.Œπ (fun (X : C) ‚Ü¶ IsLE X 0) ‚ãô G)
    (ObjectProperty.lift _ L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).1)))
    (shift : ‚àÄ (X : C), IsIso (G.map (hCP.Œ±.app X))) :
    left_adj = Adjunction.ofNatIsoLeft (ForgetFiltration_leftAdjoint L)
    (isoWhiskerLeft _ (ForgetFiltration_uniq_left L G left_adj shift)) := sorry

lemma ForgetFiltration_uniq_left_uniq (G : C ‚•§ A)
    (left_adj : Adjunction (ObjectProperty.Œπ (fun (X : C) ‚Ü¶ IsLE X 0) ‚ãô G)
    (ObjectProperty.lift _ L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).1)))
    (shift : ‚àÄ (X : C), IsIso (G.map (hCP.Œ±.app X))) (e : ForgetFiltration L ‚âÖ G)
    (compat : left_adj = Adjunction.ofNatIsoLeft (ForgetFiltration_leftAdjoint L)
    (isoWhiskerLeft _ e)) :
    e = ForgetFiltration_uniq_left L G left_adj shift := sorry

-- Second uniqueness statement: this is similar, let's not state it.

/- Property (a) implies that we have an isomorphism `L.functor ‚â´ ForgetFiltration ‚âÖ ùü≠ A`.
Property (b) gives an isomorphism in the other direction, and lemma `ForgetFiltration_iso_comp`
implies that these isomorphisms are inverses of each other.
-/
def ForgetFiltration_functor : L.functor ‚ãô ForgetFiltration L ‚âÖ ùü≠ A := by
  have := L.ff.full
  have := L.ff.faithful
  set e := (ForgetFiltration_leftAdjoint L).counit
  have : IsIso e := inferInstance
  exact isoWhiskerRight (ObjectProperty.liftCompŒπIso (fun X ‚Ü¶ IsLE X 0) L.functor
    (fun X ‚Ü¶ (isFilteredTriangulated_over_image L X).1)).symm _ ‚â™‚â´
    Functor.associator _ _ _ ‚â™‚â´ asIso e

/-
The composition in the other direction is isomorphic to `truncGELE 0 0`.
-/

def Functor_forgetFiltration : ForgetFiltration L ‚ãô L.functor ‚âÖ truncGELE 0 0 := sorry

-- So `ForgetFiltration` gives a quasi-inverse of the equivalence
-- `(isFilteredTriangulated_over_equiv L)`.
-- (Is this useful?)

def ForgetFiltration_vs_equiv :
    (ObjectProperty.Œπ (fun X ‚Ü¶ IsLE X 0 ‚àß IsGE X 0)) ‚ãô ForgetFiltration L ‚âÖ
    (isFilteredTriangulated_over_equiv L).inv := by
  refine ?_ ‚â™‚â´ Functor.rightUnitor _
  refine (Iso.inverseCompIso (G := (isFilteredTriangulated_over_equiv L).asEquivalence) ?_).symm
  refine ?_ ‚â™‚â´ Functor.associator _ _ _
  refine (ForgetFiltration_functor L).symm ‚â™‚â´ isoWhiskerRight (ObjectProperty.liftCompŒπIso
    (fun X ‚Ü¶ IsLE X 0 ‚àß IsGE X 0) _ (isFilteredTriangulated_over_image L)).symm _

end Forget

section Graded
-- Definition A.1.4.
variable (L : isFilteredTriangulated_over C A) (n : ‚Ñ§)

def Gr : C ‚•§ A := truncGELE n n ‚ãô ForgetFiltration L

-- `Gr` is triangulated.

instance (n : ‚Ñ§) : (Gr L n).CommShift ‚Ñ§ := by
  dsimp [Gr, truncGELE]; infer_instance

instance (n : ‚Ñ§) : (Gr L n).IsTriangulated := by
  dsimp [Gr, truncGELE]; infer_instance

-- Comparison with the definition in the paper:
def Gr_vs_Gr : Gr L n ‚âÖ truncGELE n n ‚ãô shiftFunctor‚ÇÇ C (-n) ‚ãô ForgetFiltration L := sorry
-- Use `ForgetFiltration_commShift`.

/-
def Gr_aux : C ‚•§ C := truncGELE n n ‚ãô shiftFunctor‚ÇÇ C (-n)

-- `Gr_aux` is triangulated.

instance (n : ‚Ñ§) : (Gr_aux (C := C) n).CommShift ‚Ñ§ := by
  dsimp [Gr_aux]; infer_instance

instance (n : ‚Ñ§) : (Gr_aux (C := C) n).IsTriangulated := by
  dsimp [Gr_aux]; infer_instance

/- The essential image of `Gr_aux` is contained in the full subcategory of objects that
are both `‚â§ 0` and `‚â• 0`.
-/
lemma Gr_aux_image (X : C) : IsLE ((Gr_aux n).obj X) 0 ‚àß IsGE ((Gr_aux n).obj X) 0 := by
  dsimp [Gr_aux]
  constructor
  ¬∑ have : IsLE ((shiftFunctor‚ÇÇ C (-n)).obj ((truncLEGE n n).obj X)) 0 := by
      dsimp [truncLEGE]
      exact isLE_shift _ n (-n) 0 (neg_add_cancel _)
    refine isLE_of_iso ((shiftFunctor‚ÇÇ C (-n)).mapIso ((asIso (truncLEGEToGELE n n)).app X)) 0
  ¬∑ dsimp [truncGELE]
    exact isGE_shift _ n (-n) 0 (neg_add_cancel _)

def Gr_aux_trunc : Gr_aux (C := C) n ‚ãô truncGELE 0 0 ‚âÖ Gr_aux n := by
  refine NatIso.ofComponents (fun X ‚Ü¶ ?_) (fun {X Y} f ‚Ü¶ ?_)
  ¬∑ have := (Gr_aux_image n X).1
    have := (Gr_aux_image n X).2
    have : IsGE ((truncLE 0).obj ((Gr_aux n).obj X)) 0 := inferInstance
    exact asIso ((truncGEŒπ 0).app ((truncLE 0).obj ((Gr_aux n).obj X))) ‚â™‚â´
      (asIso ((truncLEœÄ 0).app ((Gr_aux n).obj X))).symm
  ¬∑ dsimp
    slice_lhs 1 2 => rw [(truncGEŒπ 0).naturality, Functor.id_map]
    have := (Gr_aux_image n Y).1
    rw [‚Üê cancel_mono ((truncLEœÄ 0).app ((Gr_aux n).obj Y))]
    simp only [Functor.id_obj, assoc, IsIso.inv_hom_id, comp_id]
    have := (truncLEœÄ 0).naturality ((Gr_aux n).map f)
    simp only [Functor.id_obj, Functor.id_map] at this
    rw [this]
    simp only [IsIso.inv_hom_id_assoc]

def Gr : C ‚•§ A :=
  Gr_aux n ‚ãô ForgetFiltration L

def Gr_Gr_aux : Gr L n ‚ãô L.functor ‚âÖ Gr_aux n :=
  Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ (Functor_forgetFiltration L) ‚â™‚â´ Gr_aux_trunc n

-- `Gr` is triangulated.

instance (n : ‚Ñ§) : (Gr L n).CommShift ‚Ñ§ := by
  dsimp [Gr]; infer_instance

instance (n : ‚Ñ§) : (Gr L n).IsTriangulated := by
  dsimp [Gr]; infer_instance
-/

-- Proposition A.1.5(i).

-- Again, the isomorphisms are explicit.
def Gr_commShift : leftCommShift (fun n ‚Ü¶ Gr (C := C) L n) (E := FilteredShift C) := sorry

-- Proposition A.1.5(ii).

/-
lemma Gr_aux_pure_zero_of_ne_zero {n : ‚Ñ§} (h : n ‚â† 0) (X : A) :
    Limits.IsZero ((Gr_aux n).obj (L.functor.obj X)) := sorry
-/

lemma Gr_pure_zero_of_ne_zero {n : ‚Ñ§} (h : n ‚â† 0) (X : A) :
    Limits.IsZero ((Gr L n).obj (L.functor.obj X)) := sorry

/-
def Gr_aux_pure_of_zero (n : ‚Ñ§) (h : n = 0) : L.functor ‚ãô Gr_aux n ‚âÖ L.functor := by
  refine isoWhiskerLeft L.functor (eqToIso (by rw [h])) ‚â™‚â´ ?_
  refine (Functor.associator _ _ _).symm ‚â™‚â´ isoWhiskerLeft (L.functor ‚ãô truncGELE 0 0)
    (shiftFunctorZero' _ (-0) neg_zero) ‚â™‚â´ Functor.rightUnitor _ ‚â™‚â´ ?_
  refine NatIso.ofComponents (fun X ‚Ü¶ ?_) (fun {X Y} f ‚Ü¶ ?_)
  ¬∑ have := (isFilteredTriangulated_over_image L X).1
    have := (isFilteredTriangulated_over_image L X).2
    have : IsGE ((truncLE 0).obj (L.functor.obj X)) 0 := inferInstance
    exact asIso ((truncGEŒπ 0).app ((truncLE 0).obj (L.functor.obj X))) ‚â™‚â´
      (asIso ((truncLEœÄ 0).app (L.functor.obj X))).symm
  ¬∑ dsimp
    slice_lhs 1 2 => rw [(truncGEŒπ 0).naturality, Functor.id_map]
    have := (isFilteredTriangulated_over_image L Y).1
    rw [‚Üê cancel_mono ((truncLEœÄ 0).app (L.functor.obj Y))]
    simp only [Functor.id_obj, assoc, IsIso.inv_hom_id, comp_id]
    have := (truncLEœÄ 0).naturality (L.functor.map f)
    simp only [Functor.id_obj, Functor.id_map] at this
    rw [this]
    simp only [IsIso.inv_hom_id_assoc]
-/

def Gr_pure_of_zero (n : ‚Ñ§) (h : n = 0) : L.functor ‚ãô Gr L n ‚âÖ ùü≠ A := sorry
/-  (Functor.associator _ _ _).symm ‚â™‚â´ isoWhiskerRight (Gr_aux_pure_of_zero L n h) _ ‚â™‚â´
  ForgetFiltration_functor L
-/

-- Proposition A.1.5(iii).
-- Here the math statement doesn't say everything we want it to, because the
-- isomorphisms are not arbitrary ones, they're given by `truncLEœÄ` and `truncGEŒπ`.

lemma Gr_truncLE_zero (r n : ‚Ñ§) (h : n < r) (X : C) :
    Limits.IsZero ((truncLE n ‚ãô Gr L r).obj X) := sorry

lemma isIso_Gr_truncLEœÄ (r n : ‚Ñ§) (h : r ‚â§ n) :
    IsIso (whiskerRight (truncLEœÄ n) (Gr L r)) := sorry

lemma Gr_truncGE_zero (r n : ‚Ñ§) (h : r < n) (X : C) :
    Limits.IsZero ((truncGE n ‚ãô Gr L r).obj X) := sorry

lemma isIso_Gr_truncGEŒπ (r n : ‚Ñ§) (h : n ‚â§ r) :
    IsIso (whiskerRight (truncGEŒπ n) (Gr L r)) := sorry

end Graded

section FunctorLiftCompat

variable (L‚ÇÅ : isFilteredTriangulated_over C A) (L‚ÇÇ : isFilteredTriangulated_over D B)
  {T : A ‚•§ B} [T.CommShift ‚Ñ§] [T.IsTriangulated] (FT : T.filteredLifting L‚ÇÅ L‚ÇÇ)

/-
def filteredLifting_compat_Gr (n : ‚Ñ§) :
    Gr L‚ÇÅ n ‚ãô T ‚ãô L‚ÇÇ.functor ‚âÖ Gr_aux n ‚ãô FT.functor :=
  isoWhiskerLeft _ FT.compat ‚â™‚â´ (Functor.associator _ _ _).symm ‚â™‚â´
  isoWhiskerRight (Gr_Gr_aux L‚ÇÅ n) _
-/

-- Proposition A.1.8 is a mess.
-- Again this is not precise, the natural isomorphisms are not arbitrary!
-- Also, the square with `truncGE` is missing, and we need more squares
-- with `truncGELE`, as well as compatibilities with the connecting
-- morphisms in the triangles of `truncGELE`.

/- By what we did in the section `Commute`, the commutative squares for `truncLE` and
`truncGE` follow from the facts that :
(1) `FT` is triangulated;
(2) `FT` sends objects that are `‚â§ n` (resp. `‚â• n`) to objects that are `‚â§ n` (resp. `‚â• n`).
-/

abbrev liftFunctor_commute_truncLE (n : ‚Ñ§) : FT.functor ‚ãô truncLE n ‚ü∂ truncLE n ‚ãô FT.functor :=
  commute_truncLE FT.functor n (fun _ _ ‚Ü¶ inferInstance)

instance liftFunctor_truncLE_comm (n : ‚Ñ§) : IsIso (liftFunctor_commute_truncLE L‚ÇÅ L‚ÇÇ FT n) :=
  isIso_commute_truncLE FT.functor n (fun _ _ ‚Ü¶ inferInstance) (fun _ _ ‚Ü¶ inferInstance)

abbrev liftFunctor_commute_truncGE (n : ‚Ñ§) : truncGE n ‚ãô FT.functor ‚ü∂ FT.functor ‚ãô truncGE n :=
  commute_truncGE FT.functor n (fun _ _ ‚Ü¶ inferInstance)

instance liftFunctor_truncGE_comm (n : ‚Ñ§) : IsIso (liftFunctor_commute_truncGE L‚ÇÅ L‚ÇÇ FT n) :=
  isIso_commute_truncGE FT.functor n (fun _ _ ‚Ü¶ inferInstance) (fun _ _ ‚Ü¶ inferInstance)

-- Now the square with `Gr` follows from the ones with `truncLE` and `truncGE`,
-- since we already know that `FT` "commutes" with `s`.

/-
def lifting_Gr_aux_comm (n : ‚Ñ§) :
    FT.functor ‚ãô Gr_aux n ‚âÖ Gr_aux n ‚ãô FT.functor :=
  (Functor.associator _ _ _).symm ‚â™‚â´
  isoWhiskerRight (Functor.associator _ _ _).symm _ ‚â™‚â´
  isoWhiskerRight (isoWhiskerRight (asIso (liftFunctor_commute_truncLE L‚ÇÅ L‚ÇÇ FT n)) _) _ ‚â™‚â´
  isoWhiskerRight (Functor.associator _ _ _) _ ‚â™‚â´
  isoWhiskerRight (isoWhiskerLeft _ (asIso (liftFunctor_commute_truncGE L‚ÇÅ L‚ÇÇ FT n)).symm) _ ‚â™‚â´
  isoWhiskerRight (Functor.associator _ _ _).symm _ ‚â™‚â´
  Functor.associator _ _ _ ‚â™‚â´
  isoWhiskerLeft _ (FT.commShift.iso ((0, -n) : ‚Ñ§ √ó ‚Ñ§)).symm ‚â™‚â´
  (Functor.associator _ _ _).symm
-/

def liftin_Gr_comm_aux (n : ‚Ñ§) :
    FT.functor ‚ãô Gr L‚ÇÇ n ‚ãô L‚ÇÇ.functor ‚âÖ Gr L‚ÇÅ n ‚ãô T ‚ãô L‚ÇÇ.functor :=
  sorry
/-  isoWhiskerLeft _ (Gr_Gr_aux L‚ÇÇ n) ‚â™‚â´ lifting_Gr_aux_comm L‚ÇÅ L‚ÇÇ FT n ‚â™‚â´
  (filteredLifting_compat_Gr L‚ÇÅ L‚ÇÇ FT n).symm
-/

def lifting_Gr_comm (n : ‚Ñ§) : FT.functor ‚ãô Gr L‚ÇÇ n ‚âÖ  Gr L‚ÇÅ n ‚ãô T := by
  have := L‚ÇÇ.ff.faithful
  have := L‚ÇÇ.ff.full
  exact Functor.fullyFaithfulCancelRight L‚ÇÇ.functor (liftin_Gr_comm_aux L‚ÇÅ L‚ÇÇ FT n)

-- Commutativity by `ForgetFiltration`. Here too there must be extra compatibilities,
-- but I'm not sure what they all are. Let's see what happens later.
/-
More precisely, on `C(‚â§ 0)` (where `ForgetFiltration` is left adjoint to `i`) and on `C(‚â• 0)`
(where it is right adjoint to `i`), the morphism should be given by the `Mates` construction.
As `FT` commutes with the second shift and `ForgetFiltration` intertwines it with the identity,
the restriction of the commuting isomorphism to either `C(‚â§ 0)` or `C(‚â• 0)` determines it,
so there might be a hidden compatibility in the construction of `ForgetFiltration` that we
are missing.
-/

def lifting_forgetFiltrating_comm :
    FT.functor ‚ãô ForgetFiltration L‚ÇÇ ‚âÖ ForgetFiltration L‚ÇÅ ‚ãô T := sorry

end FunctorLiftCompat

end FilteredTriangulated

end CategoryTheory
